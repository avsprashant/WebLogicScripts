In path : /users/mwe/cgscripts

( 1.mail command in combination with nohup, avoids dead.letter )

#adminstart.sh

#!/bin/sh


if [ `whoami` != "mwadmin" ] ; then

        echo "Command ($0) may only be executed by mwadmin"

        exit 1

fi
 

###################################################################################

# send out email

###################################################################################


cd /users/mwe/cgscripts

test -f ./.cgscripts.profile && . ./.cgscripts.profile

 

nohup echo -e "`hostname` - server was restarted.\n http://atm/Search/?q=${_CG_APPLICATION_ID} " | /bin/mail \

  -s "`hostname` - Server Was Restarted (${_CG_ZONE}/${_CG_ENVIRONMENT}/${_CG_APPLICATION_ID})" "ME_APP_SERVER_ADMINS@capgroup.com" &

 
--------------------------------------------------------------------------------------------------------------------------------------------------


( 1.Intelligently used continue statement to loop thru servers and start all managed servers in every domain )

#appstart

#!/bin/ksh


if [ `whoami` != "webapp" ] ; then

   echo "Command ($0) may only be executed by webapp"

   exit 1

fi

 

for bin_dir in `ls -xd /users/domains/w*/bin` ; do

  cd ${bin_dir} || continue

  nohup ${bin_dir}/startWebLogic.sh &

  nohup ${bin_dir}/startNodeManager.sh &

  sleep 15

done

 

. /users/mwe/cgscripts/server_control_functions.sh


#Get list of domains and start all servers in every domain etc.

cd /users/domains

typeset domains=`ls -xd w*`


for dm in `echo $domains` ; do

  status_admin_server ${dm} ${dm}_adm

  echo 3

  cd ${dm}/servers || continue

  typeset servers=`ls -xd *`

  for svr in `echo $servers` ; do

     if [[ "$svr" != domain_bak && "$svr" != *_adm ]] ; then

        echo ................ $dm $svr .................

        start_mgd_server $dm $svr

     else

         continue

     fi

  done

 cd ../..


done


-----------------------------------------------------------------------------------------------------------
 

# same like above script, but checks for status of managd servers.

#appstatus

#!/bin/ksh

if [ `whoami` != "webapp" ] ; then

   echo "Command ($0) may only be executed by webapp"

   exit 1

fi

 

. /users/mwe/cgscripts/server_control_functions.sh

cd /users/domains

 

typeset domains=`ls -xd w*`

for dm in `echo $domains` ; do

 

  cd ${dm}/servers

  typeset servers=`ls -xd *`

  for svr in `echo $servers` ; do

 

     if [[ $svr != domain_bak ]] ; then

         echo ................ $dm $svr .................

         status_mgd_server $dm $svr

     else

         continue

     fi

 

  done

  cd ../..

done

 
--------------------------------------------------------------------------------------------------
 
# stops all managed servers and then admin server in every domain

#appstop

#!/bin/ksh

if [ `whoami` != "webapp" ] ; then

   echo "Command ($0) may only be executed by webapp"

   exit 1

fi

 

# pkill -u webapp

 

. /users/mwe/cgscripts/server_control_functions.sh

cd /users/domains

 

typeset domains=`ls -xd w*`

for dm in `echo $domains` ; do

 

  cd /users/domains/${dm}/servers || continue

 

  typeset servers=`ls -xd *`

  for svr in `echo $servers` ; do

 

    if [[ "$svr" != domain_bak && "$svr" != *_adm ]] ; then

         echo ................ $dm $svr .................

         stop_mgd_server $dm $svr

    else

         continue

    fi

 

  done

 

  stop_admin_server ${dm}

  cd ../..

done

---------------------------------------------------------------------------------------------------------

# we are defining start stop funcs. in python and later calling in wls-control.sh

#server_control_functions

#!/bin/ksh

WLS_COMMON=/users/mwe/weblogic12c/wlserver/common/bin

WLST_SCRIPTS=/users/mwe/cgscripts/py

 

function start_admin_server {

  typeset _domain=$1

  cd /users/domains/${_domain}/bin || exit 1

  ls -l ./startWebLogic.sh >/dev/null || exit 2

  nohup ./startWebLogic.sh 2>&1 &

}

 

function stop_admin_server {

  typeset _domain=$1

  cd /users/domains/${_domain}/bin || exit 1

  ls -l ./stopWebLogic.sh >/dev/null || exit 2

  nohup ./stopWebLogic.sh >>nohup.out 2>&1 &

}

 

function start_mgd_server {

  _raw_start_mgd_server "$@" 2>&1 | sed -n -e '/Connecting to t3/,$p'

}

 

function stop_mgd_server {

  _raw_stop_mgd_server "$@"  2>&1 | sed -n -e '/Connecting to t3/,$p'

}

 

function _raw_start_mgd_server {

  typeset _domain=$1

  typeset _server=$2

  shift 1

  cd /users/domains/${_domain}

  pwd

  echo "$@"

  pgrep -f -u webapp -x "Name=${MGD_SERVER}" | grep -v grep

  svr_status=$?

  if [[ $svr_status -gt 0 ]] ; then

    $WLS_COMMON/wlst.sh $WLST_SCRIPTS/control_managed_servers.py "start" "${_domain}" "$@"

  else

    echo server ${_server} is already started

  fi

}

 

function _raw_stop_mgd_server {

  typeset _domain=$1

  typeset _server=$2

  shift 1

  cd /users/domains/${_domain}

  pwd

  echo "$@"

  pgrep -f -u webapp ${_server} >/dev/null 2>/dev/null

  svr_status=$?

  if [[ $svr_status -eq 0 ]] ; then

    $WLS_COMMON/wlst.sh $WLST_SCRIPTS/control_managed_servers.py "stop" "${_domain}" "$@"

  else

    echo server ${_server} is already stoped

  fi

}

 

function bounce_mgd_server {

  typeset _domain=$1

  shift 1

  cd /users/domains/${_domain}

  $WLS_COMMON/wlst.sh $WLST_SCRIPTS/control_managed_servers.py "bounce" "${_domain}" "$@"

}

 

function status_mgd_server {

  MGD_SERVER=${2:?"Parameter 2 required: managed server"}

  pid=`pgrep -f -u webapp "Name=${MGD_SERVER}" | grep -v grep`

  if [ -n "$pid" ] ; then

      echo "WebLogic ${MGD_SERVER} is running and it's PID(s) is ${pid} !"

  else

      echo "ERROR: ${MGD_SERVER} is NOT running!"

  fi

}

 

function status_admin_server {

  ADM_SERVER=${2:?"Parameter 2 required: admin server"}

  pid=`pgrep -f -u webapp "Name=${ADM_SERVER}" | grep -v grep`

  if [ -n "$pid" ] ; then

        echo "WebLogic ${ADM_SERVER} is running and it's PID(s) is ${pid} !"

  else

        echo "ERROR: ${ADM_SERVER} is NOT running!"

  fi

}

----------------------------------------------------------------------------------------------------------

#wls-control

#!/bin/ksh

 

#  History

# =========

# 08-26-2010    btt     Created

# 09-10-2010    mwo     Adapted for weblogic

# 09-12-2013    mwo     Added bounce function for AF WAS migration

#######################################################################

 

if [ `whoami` != "webapp" ] ; then

    echo "Command ($0) may only be executed by webapp"

    exit 1

fi

 

DOMAIN=${1:?"Parameter 1 required: domain"}

MGD_SERVER=${2:?"Parameter 2 required: managed server"}

FUNCTION=${3:?"Parameter 3 required: start|stop|status|bounce"}

 

. /users/mwe/cgscripts/server_control_functions.sh

cd /users/domains

if [ ! -d ${DOMAIN} ] ; then

    ls -ld ${DOMAIN}

    echo "domain (${DOMAIN}) not found"

    exit 2

fi

 

# check_and_start_all_nm

 

case ${FUNCTION} in

    start)

        start_mgd_server ${DOMAIN} ${MGD_SERVER}

        ;;

    stop)

        stop_mgd_server  ${DOMAIN} ${MGD_SERVER}

        ;;

    status)

        status_mgd_server  ${DOMAIN} ${MGD_SERVER}

        ;;

    bounce)

        bounce_mgd_server  ${DOMAIN} ${MGD_SERVER}

        ;;

    *)

        echo "Invalid function: " ${FUNCTION}

        ;;

esac

 

/users/mwe/cgscripts/py

 

#admin_map.txt

#wdx036322=x036322:8000

wpx591384=x591384:8000

 

#control_managed_servers.py

import os

from time import sleep

 

#function=os.getenv("_function")

#domain=os.getenv("_domain")

 

admin_map_file_name="/users/mwe/cgscripts/py/admin_map.txt"

domain_admin_map={}

 

def init_admin_map():

lines=open(admin_map_file_name).readlines()

for l in lines:

  if (l.startswith("#")):

   pass

  else:

   try:

    domain_admin_map[l.split("=")[0]]=l.split("=")[1].strip()

   except IndexError:

    pass

 

def start_mgd_servers(domain, mgd_servers):

#Note: managed server names are passed in sys.argv[]

try:

  connect(url="t3://"+domain_admin_map[domain],adminServerName=domain+"_adm")

except WLSTException:

  print "connect failed - will retry after 30 seconds"

  sleep(30)

  try:

   connect(url="t3://"+domain_admin_map[domain],adminServerName=domain+"_adm")

  except WLSTException:

   print "connect failed - will retry after 30 seconds"

   sleep(30)

   try:

    connect(url="t3://"+domain_admin_map[domain],adminServerName=domain+"_adm")

   except WLSTException:

    print "connect failed - will retry after 60 seconds"

    sleep(60)

    connect(url="t3://"+domain_admin_map[domain],adminServerName=domain+"_adm")

for mgd_server in mgd_servers[:]:

  #state(mgd_server)

  print "starting ",mgd_server

  start(mgd_server, block="true")

  state(mgd_server)

disconnect()

 

def stop_mgd_servers(domain, mgd_servers):

#Note: managed server names are passed in sys.argv[]

try:

  connect(url="t3://"+domain_admin_map[domain],adminServerName=domain+"_adm")

except WLSTException:

  print "connect failed - will retry after 15 seconds"

  sleep(15)

  connect(url="t3://"+domain_admin_map[domain],adminServerName=domain+"_adm")

for mgd_server in mgd_servers[:]:

  #state(mgd_server)

  print "stopping ",mgd_server

  shutdown(mgd_server, "Server", timeOut=10000, block="true")

  state(mgd_server)

disconnect()

 

 

def bounce_mgd_servers(domain, mgd_servers):

try:

  connect(url="t3://"+domain_admin_map[domain],adminServerName=domain+"_adm")

except WLSTException:

  print "connect failed - will retry after 15 seconds"

  sleep(15)

  connect(url="t3://"+domain_admin_map[domain],adminServerName=domain+"_adm")

for mgd_server in mgd_servers[:]:

  print "stopping ",mgd_server

  try:

   shutdown(mgd_server, "Server", timeOut=10000, force="true", block="true")

  except WLSTException:

   # ignore exception - assume server was already stopped, and proceed with bounce

   print "..." ,

  state(mgd_server)

sleep(30)

for mgd_server in mgd_servers[:]:

  print "starting ",mgd_server

  start(mgd_server, block="true")

  state(mgd_server)

disconnect()

 

 

def main():

prompt("off")

sys.ps1=""

init_admin_map()

function=sys.argv[1]

domain=sys.argv[2]

print function

print domain

mgd_server_list = []

for mgd_server in sys.argv[3:]:

#  if (mgd_server.startswith(domain)):

   mgd_server_list.append(mgd_server)

#  else:

#   mgd_server_list.append(domain + "_" + mgd_server)

  

 if (function == "start"):

  start_mgd_servers(domain, mgd_server_list)

elif (function == "stop"):

  stop_mgd_servers(domain, mgd_server_list)

elif (function == "bounce"):

  bounce_mgd_servers(domain, mgd_server_list)

exit()

 

if __name__ == "main":

sys.exit(main())

 

 

/users/mwtools/tc

 

#cg-tcruntime-instance-v296.sh

#tomcat instance Installation

 

#!/bin/sh

#

# Usage:

# Edit APP_NAME="...." with the real app name (i.e. crd, fxp, etc.)

# Edit APP_INSTANCE="..." with the desired release version (i.e. 1.0, v1.1, etc.)

# Then create the new instance as below -

# ./cg-tcruntime-instance.sh fxp fxpD01 1.0 81    First Dev 8100 instance

# ./cg-tcruntime-instance.sh pcs fxpD02 1.0 82   Second Dev 8200 instance

#

# ./cg-tcruntime-instance.sh fxp fxpD01 1.1 81  Updated App release 1.1 on the 1st instance

#

# Date                   Version                Description

# ==========================================

# 07/01/10          1.0                          Created by BTT

# 07/23/10          1.1                          Added tcserver softlink and check for APP_HOME

#                               Replaced tcserver202 and 8443 for https.port

# 07/28/10          1.2                          Remove cgapp directory

# 07/30/10          1.3                          Updated for create new instance and setenv.sh of old instance

# 10/06/10                                          Remove the xmlValidation

# 04/29/11          2.0                          Added jdk command line input with the defaulted jdk1.6.0_24

# 06/10/11                                          Updated the defaulted jdk1.6.0_24 to jdk1.6.0_32

# 04/07/14                      Added JAVA_HOME export; Must edit tcruntime-ctl.sh:INSTALL_BASE variable

# 05/29/14          2.6                          Modify for tcserver 2.9.6

#

 

if [ $# -lt 1 ]; then

   echo "Usage: $0 app-name app-instance version port [jdk version]"

   echo "Examples -"

   echo "  ./cg-tcruntime-instance.sh fxp fxpD01 1.0 81 jdk1.6.0_32"

   echo "  ./cg-tcruntime-instance.sh fxp fxpD01 1.0 81 -> defaulted to jdk1.6.0_32"

   exit 22

fi

 

if [ `whoami` != "webapp" ]; then

   echo "Must be webapp to run this script ..."

   exit 1

fi

 

APP_NAME=$1

TC_HOME="/users/mwe/tcserver"

TCVER="7.0.72.A.RELEASE"

JAVA_HOME="/users/java/jdk1.7.0_161"

INSTANCE_NAME=$2

APP_INSTANCE="$3"

APP_HOME="/users/domains/tomcat/$APP_NAME/$INSTANCE_NAME"

#JAVA_HOME="/users/domains/tomcat/$APP_NAME/$INSTANCE_NAME/jdk"

if [ -z "$5" ]; then

   echo "JDK is defaulted to jdk1.7.0_161 now ..."

   JDK_VERSION="jdk1.7.0_161"

else 

   JDK_VERSION=$5

fi

HTTP_PORT=$4"02"

HTTPS_PORT=$4"03"

JMX_PORT=$4"04"

AJP_PORT=$4"05"

 

echo

echo "Here are your installation info -"

echo "================================="

echo "TC_HOME="$TC_HOME

echo "TCVER="$TCVER

echo "JAVA_HOME="$JAVA_HOME

echo "JDK_VERSION="$JDK_VERSION

echo "INSTANCE_NAME="$INSTANCE_NAME

echo "APP_INSTANCE="$APP_INSTANCE

echo "APP_HOME="$APP_HOME

echo "HTTP_PORT="$HTTP_PORT

echo "HTTPS_PORT="$HTTPS_PORT

echo "JMX_PORT="$JMX_PORT

#echo "AJP_PORT="$AJP_PORT

echo

if [[ -d /users/mwe/$JDK_VERSION ]] ; then

   echo $JDK_VERSION" is found ..."

else

   echo $JDK_VERSION" is not found, defaulted to jdk1.7.0_161 ..."

   JDK_VERSION="jdk1.7.0_161"

   echo "JDK_VERSION="$JDK_VERSION

   echo

fi

echo "Press enter if it is OK or Ctrl+C to exit ..."

read answer

 

if [[ -d /users/domains/tomcat/$APP_NAME ]] ; then

   echo $APP_NAME" directory is already exist ..."

else

   mkdir /users/domains/tomcat/$APP_NAME

fi

 

if [[ -d $APP_HOME ]] ; then

   echo $APP_HOME" directory is already exist ..."

else

   mkdir $APP_HOME

fi

 

# Set up the jdk softlink

echo "Set-up the jdk softlink ..."

cd /users/domains/tomcat/$APP_NAME/$INSTANCE_NAME

ln -s /users/mwe/jdk $APP_HOME/jdk

export JAVA_HOME="$APP_HOME/jdk"

 

echo "Creating instance ..."

echo "JAVA_HOME="$JAVA_HOME

 

cd $TC_HOME

#./tcruntime-instance.sh create -i $APP_HOME -v $TCVER --java-home $JAVA_HOME -p bio.http.port=$HTTP_PORT -p bio.https.port=$HTTPS_PORT -p base.jmx.port=$JMX_PORT -t bio -t bio-ssl $APP_INSTANCE

./tcruntime-instance.sh create -i $APP_HOME -v $TCVER --java-home $JAVA_HOME -p bio.http.port=$HTTP_PORT -p bio.https.port=$HTTPS_PORT -p base.jmx.port=$JMX_PORT $APP_INSTANCE

 

echo

echo "Start CG customized process ..."

echo "Set-up CATALINA_HOME and CATALINA_BASE soft links ..."

cp $APP_HOME/$APP_INSTANCE/bin/setenv.sh $APP_HOME/$APP_INSTANCE/bin/setenv.sh.org

cp /users/mwtools/tc/cg-setenv.sh $APP_HOME/$APP_INSTANCE/bin/setenv.sh

 

echo "CATALINA_HOME=$TC_HOME/tomcat" >> $APP_HOME/$APP_INSTANCE/bin/setenv.sh

echo "CATALINA_BASE=$APP_HOME/current" >> $APP_HOME/$APP_INSTANCE/bin/setenv.sh

 

cd $APP_HOME

 

# if this another instance then update the setenv of the old instance

if [[ -d $APP_HOME/current ]] ; then

   OLDDIR=`find . -type l | xargs ls -l | awk '{print $NF}'`

   cd current/bin

   echo "Reset CATALINA_BASE of the current instance -> "$APP_HOME"/"$OLDDIR

   cat setenv.sh | sed -e "s/current/${OLDDIR}/" > setenv.sh.cg

   mv setenv.sh.cg setenv.sh

   chmod a+x setenv.sh

   cd ../..

   rm current

fi

ln -s $APP_INSTANCE current

chmod -R 755 $APP_INSTANCE

# Replace tcserver296 with the tcserver softlink

echo "Set-up the tcserver softlink ..."

cd $APP_HOME/current/bin

cat tcruntime-ctl.sh | sed -e "s/tcserver321/tcserver/" > tcruntime-ctl.sh.cg

mv tcruntime-ctl.sh.cg tcruntime-ctl.sh

chmod a+x tcruntime-ctl.sh

 

# Set JAVA_HOME for the new setenv.sh

cat setenv.sh | sed -e "s/jh_app/$APP_NAME/" > setenv.sh.cg

cat setenv.sh.cg | sed -e "s/jh_instance/$INSTANCE_NAME/" > setenv.sh

rm setenv.sh.cg

chmod a+x setenv.sh

 

# Replace https port 8443 with the new port

#echo "Set-up the https port ..."

cd $APP_HOME/current/conf

#cat catalina.properties | sed -e "s/8443/${HTTPS_PORT}/" > catalina.properties.cg

#mv catalina.properties.cg catalina.properties

 

# Turn off the unpack or exploded WAR file.

echo "Turn-off the unpack or exploded WAR file ..."

cat server.xml | sed -e 's/unpackWARs="true"/unpackWARs="false"/' > server.xml.cg

# cat server.xml.cg | sed -e 's/xmlValidation="false"/xmlValidation="true"/' > server.xml.cg1

# rm server.xml.cg

mv server.xml.cg server.xml

 

 

/users/mwe/tcserver

 

#tc native installation scripts

#tcruntime-ctl.sh

#!/bin/sh

 

# ---------------------------------------------------------------------------

# tc Runtime Control Script

#

# Copyright (c) 2010-2012 VMware, Inc.  All rights reserved.

# ---------------------------------------------------------------------------

# version: 2.9.6.RELEASE

# build date: 20140522144433

 

TCRUNTIME_VER=2.9.6.RELEASE

 

### don't muddy the whole environment

MY_INSTANCE_BASE="$INSTANCE_BASE"

unset INSTANCE_BASE

export INSTANCE_BASE

INSTANCE_BASE="$MY_INSTANCE_BASE"

RUN_FROM_INSTANCE="$INSTANCE_BASE"

# Uncomment to change the location of where runtime instances will be installed

# and override any possible setting via the instance script

#INSTANCE_BASE=setme

 

#function that prints out usage syntax

syntax () {

  if [ -z "$RUN_FROM_INSTANCE" ]; then

    echo "Usage from tc Runtime installation directory:"

    echo "./tcruntime-ctl.sh instance_name cmd [options]"

    echo " "

    echo "  [options]"

    echo "     -i <dir>, -n <dir>  - The full path to the instances directory [default:"

    echo "                           current working directory]"

    echo "     -d <dir>            - The full path to the tc Runtime installation"

    echo "                           directory [default: location of this script]"

    echo " "

  else

    echo "Usage from tc Runtime instance directory:"

    echo "./tcruntime-ctl.sh cmd"

    echo " "

  fi

    echo "  cmd is one of start | run | stop | restart | status"

    echo "    start             - starts a tc Runtime instance as a daemon process"

    echo "    run               - starts a tc Runtime instance as a foreground process"

    echo "    stop [timeout]    - stops a running tc Runtime instance, forcing termination"

    echo "                        of the process if it does not exit gracefully within"

    echo "                        timeout seconds [default: 5 seconds]"

    echo "    restart [timeout] - restarts a running tc Runtime instance, forcing"

    echo "                        termination of the process if it does not exit"

    echo "                        gracefully within timeout seconds [default: 5 seconds]"

    echo "    status            - reports the status of a tc Runtime instance"

                echo "    verbose-status   - gives a tc Runtime instance details and status"

    echo " "

    echo " "

}

 

#find out the absolute path of the script

setupdir () {

  PRG="$0"

 

  while [ -h "$PRG" ]; do

    ls=`ls -ld "$PRG"`

    link=`expr "$ls" : '.*-> \(.*\)$'`

    if expr "$link" : '/.*' > /dev/null; then

      PRG="$link"

    else

      PRG=`dirname "$PRG"`/"$link"

    fi

  done

  # Get standard environment variables

  PRGDIR=`dirname "$PRG"`

 

  #Absolute path

  PRGDIR=`cd "$PRGDIR" ; pwd -P`

  SCRIPT_DIRECTORY="$PRGDIR"

 

  while [ $# -gt 0 ]; do

    case $1 in

      -d )

        PRGDIR="$2"

        break

        ;;

    esac

    shift

  done

 

  if [ ! -r "$PRGDIR" ]; then

    echo "ERROR: tc Runtime directory $PRGDIR does not exist or is not readable."

    exit 1

  fi

}

 

setupINSTANCE_NAMEandCOMMANDandTIMEOUT() {

  while [ $# -gt 0 ]; do

    case $1 in

      -* )

        shift

        ;;

      * )

        if [ $# -lt 2 ]; then

          echo "ERROR: Invalid number of arguments on command-line."

          syntax

          exit 1

        fi

        INSTANCE_NAME=`echo $1 | sed 's/\/$//g'`

        COMMAND=$2

        if [ "$3" != -* ]; then

          TIMEOUT=$3

        fi

        break

        ;;

    esac

    shift

  done

}

 

setupINSTANCE_BASE() {

  while [ $# -gt 0 ]; do

    case $1 in

      -n )

        INSTANCE_BASE="$2"

        break

        ;;

      -i )

        INSTANCE_BASE="$2"

        break

        ;;

    esac

    shift

  done

 

 

  # The default directory where instances of tc Runtime will be created

  [ -z "$INSTANCE_BASE" ] && INSTANCE_BASE=`pwd -P`

}

 

setupCATALINA_BASE () {

  if [ "$COMMAND" = "create" ]; then

    if [ ! -x "$INSTANCE_BASE" ]; then

      echo "ERROR: Instance directory not writeable (${INSTANCE_BASE})."

      exit 1

    else

      return

    fi

  fi

 

  CATALINA_BASE=$INSTANCE_BASE/$INSTANCE_NAME

 

  if [ ! -r "$CATALINA_BASE" ]; then

    echo "ERROR: CATALINA_BASE directory $CATALINA_BASE does not exist or is not readable."

    exit 1

  fi

  if [ ! -d "$CATALINA_BASE" ]; then

    echo "ERROR: CATALINA_BASE $CATALINA_BASE is not a directory."

    exit 1

  fi

 

  CATALINA_BASE=`cd "$CATALINA_BASE"; pwd -P`

  INSTANCE_NAME=`basename "$CATALINA_BASE"`

}

 

testVersion() {

    TC_MAJOR_VERSION=`echo $1 | awk '{ print substr($1, 1, 1); }'`

    if ([ "$TC_MAJOR_VERSION" != "6" ] && [ "$TC_MAJOR_VERSION" != "7" ]); then

      return 1

    fi

    return 0

}

 

getTC_MAJOR_VERSION() {

    TC_FILE_VERSION=`cat "$CATALINA_BASE/conf/tomcat.version"`

                CURRENT_TC_VERSION="$TC_FILE_VERSION"

    if ([ "$TC_FILE_VERSION" = *"/"* ] || [ "$TC_FILE_VERSION" = *"\\"* ]); then

      TEMP_TOMCAT_VER=`echo $TC_FILE_VERSION | sed -e 's/^.*tomcat-//'`

     CURRENT_TC_VERSION="$TEMP_TOMCAT_VER"

    elif [ -n "$TC_FILE_VERSION" ]; then

                  TEMP_TOMCAT_VER="$TC_FILE_VERSION"

    fi

                testVersion "$TEMP_TOMCAT_VER"

    if [ $? -eq 1 ]; then

      TC_MAJOR_VERSION="7"

    fi

}

 

getTOMCAT_VERSION () {

  # tomcat.version can contain just the version number (eg: 6.0.20.A)

  # or the full pathname (eg: /foo/bar/tomcat-6.0.20.A), so we need

  # to handle both. If TOMCAT_VER is already provided, just use that

  if [ -z "$TOMCAT_VER" ]; then

    if [ -r "$CATALINA_BASE/conf/tomcat.version" ]; then

      # read TOMCAT_VER2 < "$CATALINA_BASE/conf/tomcat.version"

      TOMCAT_VER2=`cat "$CATALINA_BASE/conf/tomcat.version"`

      if [ -d "$PRGDIR/tomcat-$TOMCAT_VER2" ]; then

        CATALINA_HOME=`cd "$PRGDIR/tomcat-$TOMCAT_VER2" ; pwd -P`

        TOMCAT_VER="$TOMCAT_VER2"

      elif [ -d "$TOMCAT_VER2" ]; then

        CATALINA_HOME=`cd $TOMCAT_VER2 ; pwd -P`

        TOMCAT_VER=`echo $TOMCAT_VER2 | sed -e 's/^.*tomcat-//'`

      fi

    fi

    testVersion "$TOMCAT_VER"

    if [ $? -eq 1 ]; then

                  getTC_MAJOR_VERSION

      TOMCAT_VER=`ls -d -r "$PRGDIR/tomcat-$TC_MAJOR_VERSION"* | head -1 | sed -e 's/^.*tomcat-//'`

      echo "Warning: Unable to locate tomcat runtime version "$CURRENT_TC_VERSION", using the latest version "$TOMCAT_VER"."

      echo "Warning: Please update the tomcat.version to a valid version."

    fi

  fi

}

 

getLAYOUT() {

  LAYOUT=`cat "$CATALINA_BASE/.layout"`

}

 

getCATALINA_PID() {

  source $CATALINA_BASE/bin/setenv.sh

  if [ -z "$CATALINA_PID" ]; then

    CATALINA_PID="$CATALINA_BASE/logs/tcserver.pid"

  fi

}

 

setupCATALINA_HOME () {

  #Setup CATALINA_HOME to point to our binaries

  if [ "$LAYOUT" = "combined" ]; then

    CATALINA_HOME=$CATALINA_BASE

  else

    [ -z "$CATALINA_HOME" ] && CATALINA_HOME=`cd "$PRGDIR/tomcat-$TOMCAT_VER" ; pwd -P`

    if [ ! -r "$CATALINA_HOME" ]; then

      echo "ERROR: CATALINA_HOME directory $CATALINA_HOME does not exist or is not readable."

      exit 1

    fi

  fi

}

 

noop () {

  echo -n ""

}

 

isrunning() {

  #returns 0 if the process is running

  #returns 1 if the process is not running, or file was removed.

  #returns 2 if the process state is unknown

  if [ -f "$CATALINA_PID" ]; then

        # The process file exists, make sure the process is not running

        PID=`cat "$CATALINA_PID"`

        if [ -z $PID ]; then

            return 2;

        fi

        LINES=`ps -p $PID`

        PIDRET=$?

        if [ $PIDRET -eq 0 ];

        then

            export PID

            return 0;

        fi

        rm -f "$CATALINA_PID"

    fi

    return 1

}

 

 

instance_start() {

    isrunning

    if [ $? -eq 0 ]; then

      echo "ERROR: Instance is already running as PID=$PID."

      exit 1

    fi

    "$SCRIPT_TO_RUN" start

    sleep 2

    isrunning

    evaluateStatusAndExit $?

}

 

instance_run() {

    isrunning

    if [ $? -eq 0 ]; then

      echo "ERROR: Instance is already running as PID=$PID."

      exit 1

    fi

    # catalina.sh won't create a PID file when using the run command

    if [ ! -f "$CATALINA_PID" ]; then

      local TEMP_MAJOR_VERSION=`echo ${TOMCAT_VER} | awk '{ print substr($1, 1, 1); }'`

      if [ "${TEMP_MAJOR_VERSION}" == "7" ]; then

        echo "" > "$CATALINA_PID"

      else

        echo $$ > "$CATALINA_PID"

      fi

    fi

    exec "$SCRIPT_TO_RUN" run

}

 

instance_stop() {

    if [ -z "$TIMEOUT" ]; then

      WAIT_FOR_SHUTDOWN=60

    else

      # Add a leading zero to $TIMEOUT else -n may be treated as a switch for echo

      echo "0$TIMEOUT" | grep "[^0-9]" > /dev/null 2>&1

      if [ "$?" -eq "0" ]; then

        # If the grep found something other than 0-9

        # then it's not an integer.

        WAIT_FOR_SHUTDOWN=5

      else

        WAIT_FOR_SHUTDOWN=$TIMEOUT

      fi

    fi

 

    isrunning

    RUNNING=$?

    if [ $RUNNING -eq 0 ]; then

        #tomcat process is running

        echo "Instance is running as PID=$PID, shutting down..."

        kill $PID

    elif [ $RUNNING -eq 2 ]; then

        echo "No action taken. Unable to stop Tomcat 7-based instance that was started as a foreground process. Use CTRL+C in the console of the process to stop the instance"

        return 2

    else

        #if the log file is not there then it is likely someone may have clean out the contents of the log directory, including the pid file

        #or they are trying to stop a new instance.

        CATALINA_LOG="${CATALINA_BASE}/logs/catalina.out"

        if [ -f "${CATALINA_LOG}" ]; then

            echo "Instance is not running. No action taken"

        else

            echo "Running state is unknown. Expected pid file '${CATALINA_PID}' was not found."

            return 2

        fi

        return 1

    fi

    isrunning

    if [ $? -eq 0 ]; then

        #process still exists

        echo "Instance is running PID=$PID, sleeping for up to $WAIT_FOR_SHUTDOWN seconds waiting for shutdown"

        i=0

        while [ $i -lt $WAIT_FOR_SHUTDOWN ]; do

            sleep 1

            isrunning

            if [ $? -eq 1 ]; then

                break

            fi

            i=`expr $i + 1`

        done

    fi

 

    # CAN_DELETE_PID = 0 is Yes, any other number is no.

    CAN_DELETE_PID=1

    isrunning

    if [ $? -eq 0 ];

    then

        echo "Instance is still running PID=$PID, forcing a shutdown"

        kill -9 $PID

        CAN_DELETE_PID=$?

    else

        echo "Instance shut down gracefully"

        CAN_DELETE_PID=0

    fi

    if [ ${CAN_DELETE_PID} -eq 0 ]; then

       if [ -f "$CATALINA_PID" ]; then

          rm -f "$CATALINA_PID"

       fi

    else

       echo "Unable to stop process PID=${PID}."

       exit 1

    fi

}

 

instance_restart() {

    instance_stop $@

    if [ $? -eq 0 ]; then

        instance_start

    fi

    exit $?

 

}

 

instance_status() {

    echo "Instance name:         ${INSTANCE_NAME}"

    echo "Runtime version:       ${TOMCAT_VER}"

    echo "tc Runtime Base:       ${CATALINA_BASE}"

    isrunning

    evaluateStatusAndExit

}

 

evaluateStatusAndExit() {

    RUNNING=$?

    if [ $RUNNING -eq 0 ]; then

      echo "Status:                RUNNING as PID=$PID"

    elif [ $RUNNING -eq 2 ]; then

      echo "Status:                UNKNOWN due to Tomcat 7-based instance being started as a foreground process"

    else

      echo "Status:                NOT RUNNING"

    fi

    if [ -z "$1" ]; then

      exit 0

    else

      exit $1

    fi

}

 

instance_verbose_status() {

    echo "Instance name:         ${INSTANCE_NAME}"

    echo "Runtime version:       ${TOMCAT_VER}"

    echo "tc Runtime Base:       ${CATALINA_BASE}"

    echo "tc Runtime Home:       ${CATALINA_HOME}"

    echo "tc Runtime Install dir:${PRGDIR}"

    echo "Instances directory:   ${INSTANCE_BASE}"

    echo "Script directory:      ${SCRIPT_DIRECTORY}"

    echo "Script version:        ${TCRUNTIME_VER}"

    isrunning

    evaluateStatusAndExit

}

 

 

# MAIN SCRIPT EXECUTION

setupdir "$@"

setupINSTANCE_NAMEandCOMMANDandTIMEOUT "$@"

if [[ -z "$INSTANCE_NAME" || -z "$COMMAND" ]]; then

                echo "ERROR: Instance name or command was not specified"

                syntax

                exit 1

fi

setupINSTANCE_BASE "$@"

setupCATALINA_BASE "$@"

getTOMCAT_VERSION "$@"

getLAYOUT "$@"

getCATALINA_PID "$@"

setupCATALINA_HOME "$@"

 

 

#CATALINA_PID="$CATALINA_BASE/logs/tcserver.pid"

SCRIPT_TO_RUN="$CATALINA_HOME/bin/catalina.sh"

[ -z "$LOGGING_MANAGER" ] && LOGGING_MANAGER="-Djava.util.logging.manager=com.springsource.tcserver.serviceability.logging.TcServerLogManager"

[ -z "$LOGGING_CONFIG" ] && LOGGING_CONFIG="-Djava.util.logging.config.file=$CATALINA_BASE/conf/logging.properties"

 

export CATALINA_HOME

export CATALINA_BASE

export CATALINA_PID

export SCRIPT_TO_RUN

export LOGGING_CONFIG

export LOGGING_MANAGER

export INSTANCE_NAME

 

# Check cmd is expected

if [ "$COMMAND" != "start" ] && [ "$COMMAND" != "run" ] && [ "$COMMAND" != "stop" ] && [ "$COMMAND" != "restart" ] && [ "$COMMAND" != "status" ] && [ "$COMMAND" != "verbose-status" ]; then

    echo " "

    echo "ERROR: Invalid command $COMMAND"

    echo " "

    syntax

    exit 1

fi

if [ "$COMMAND" = "verbose-status" ]; then

                instance_verbose_status $@

else

    #execute the correct function

    instance_$COMMAND $@

fi

 

#tcruntime-instance.sh

 

#!/bin/sh

# ---------------------------------------------------------------------------

# tc Runtime Provisioning Script

#

# Copyright (c) 2010 VMware, Inc.  All rights reserved.

# ---------------------------------------------------------------------------

# version: 2.9.6.RELEASE

# build date: 20140522144433

 

if [ -z "$JAVA_HOME" ]

then

    echo The JAVA_HOME environment variable is not defined

    exit 1

fi

 

SCRIPT="$0"

 

# SCRIPT may be an arbitrarily deep series of symlinks. Loop until we have the concrete path.

while [ -h "$SCRIPT" ] ; do

  ls=`ls -ld "$SCRIPT"`

  # Drop everything prior to ->

  link=`expr "$ls" : '.*-> \(.*\)$'`

  if expr "$link" : '/.*' > /dev/null; then

    SCRIPT="$link"

  else

    SCRIPT=`dirname "$SCRIPT"`/"$link"

  fi

done

 

RUNTIME_DIR=`dirname "$SCRIPT"`

INSTANCE_DIR=$PWD

 

CLASSPATH=""

 

LIB_DIR=`dirname "$SCRIPT"`/lib

for file in "$LIB_DIR"/*

do

                suffix=`echo "${file##*.}"`

                if [ $suffix = jar ]

                then

                    if [ "$CLASSPATH" ]

                                then     

                        CLASSPATH=$CLASSPATH:$file

                    else

                        CLASSPATH=$file

                    fi

                fi

done

 

$JAVA_HOME/bin/java $JAVA_OPTS "-Druntime.directory=$RUNTIME_DIR" "-Ddefault.instance.directory=$INSTANCE_DIR" -classpath "$CLASSPATH" com.springsource.tcruntime.instance.TcRuntimeInstance "$@"

EXIT_CODE=$?

 

exit $EXIT_CODE
